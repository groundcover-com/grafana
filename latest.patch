diff --git a/.github/workflows/pr.yaml b/.github/workflows/pr.yaml
new file mode 100644
index 00000000000..03cf1b7fa88
--- /dev/null
+++ b/.github/workflows/pr.yaml
@@ -0,0 +1,53 @@
+name: pr
+
+on:
+ pull_request:
+
+jobs:
+  build:
+    runs-on: ubuntu-latest
+    permissions:
+      contents: write
+      id-token: write
+    steps:
+      -
+        name: Checkout
+        uses: actions/checkout@v3
+      - name: Free Disk Space (Ubuntu)
+        uses: jlumbroso/free-disk-space@main
+        with:
+          # this might remove tools that are actually needed,
+          # if set to "true" but frees about 6 GB
+          tool-cache: false
+
+          # all of these default to true, but feel free to set to
+          # "false" if necessary for your workflow
+          android: true
+          dotnet: true
+          haskell: true
+          large-packages: true
+          docker-images: true
+          swap-storage: true
+      -
+        name: Set up QEMU
+        uses: docker/setup-qemu-action@v3
+        with:
+          platforms: arm64
+      -
+        name: Set up Docker Buildx
+        uses: docker/setup-buildx-action@v3
+      -
+        name: Get Grafana Version
+        run: echo "GF_VERSION=$(npm pkg get version | tr -d '"')" >> $GITHUB_ENV
+      -
+        name: Build Docker Image
+        uses: docker/build-push-action@v5
+        with:
+          context: .
+          push: false
+          target: groundcover
+          cache-from: type=gha
+          cache-to: type=gha,mode=max
+          platforms: linux/amd64,linux/arm64
+          build-args: GF_VERSION=${{ env.GF_VERSION }}
+          tags: grafana-groundcover
diff --git a/.github/workflows/release.yaml b/.github/workflows/release.yaml
new file mode 100644
index 00000000000..41ae32197f9
--- /dev/null
+++ b/.github/workflows/release.yaml
@@ -0,0 +1,76 @@
+name: release
+
+on:
+  push:
+    tags:
+      - 'v*.*.*'
+
+jobs:
+  release:
+    runs-on: ubuntu-latest
+    permissions:
+      contents: write
+      id-token: write
+    steps:
+      -
+        name: Checkout
+        uses: actions/checkout@v3
+      - name: Free Disk Space (Ubuntu)
+        uses: jlumbroso/free-disk-space@main
+        with:
+          # this might remove tools that are actually needed,
+          # if set to "true" but frees about 6 GB
+          tool-cache: false
+
+          # all of these default to true, but feel free to set to
+          # "false" if necessary for your workflow
+          android: true
+          dotnet: true
+          haskell: true
+          large-packages: true
+          docker-images: true
+          swap-storage: true
+      -
+        name: Set up QEMU
+        uses: docker/setup-qemu-action@v3
+        with:
+          platforms: arm64
+      -
+        name: Set up Docker Buildx
+        uses: docker/setup-buildx-action@v3
+      -
+        name: Login to Quay.io
+        uses: docker/login-action@v3
+        with:
+          registry: quay.io
+          username: ${{ secrets.QUAY_USERNAME }}
+          password: ${{ secrets.QUAY_ROBOT_TOKEN }}
+      -
+        name: Configure AWS credentials
+        uses: aws-actions/configure-aws-credentials@v4
+        with:
+          aws-region: us-east-1
+          role-to-assume: arn:aws:iam::125608480246:role/grafana-github-actions
+      -
+        name: Login to Amazon ECR Public
+        id: login-ecr-public
+        uses: aws-actions/amazon-ecr-login@v2
+        with:
+          registry-type: public
+      -
+        name: Get Grafana Version
+        run: echo "GF_VERSION=$(npm pkg get version | tr -d '"')" >> $GITHUB_ENV
+      -
+        name: Build Docker Image
+        uses: docker/build-push-action@v5
+        with:
+          context: .
+          push: true
+          target: groundcover
+          cache-from: type=gha
+          cache-to: type=gha,mode=max
+          platforms: linux/amd64,linux/arm64
+          build-args: GF_VERSION=${{ env.GF_VERSION }}
+          tags: |
+            quay.io/groundcover/grafana-groundcover:${{ github.ref_name	}}-grafana${{ env.GF_VERSION }}
+            public.ecr.aws/groundcovercom/grafana-groundcover:${{ github.ref_name	}}-grafana${{ env.GF_VERSION }}
\ No newline at end of file
diff --git a/Dockerfile b/Dockerfile
index 416b2a5b5b8..8fa90f82e2e 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,9 +1,10 @@
 # syntax=docker/dockerfile:1
 
+ARG GF_VERSION=11.2.0
 ARG BASE_IMAGE=alpine:3.19.1
 ARG JS_IMAGE=node:20-alpine
 ARG JS_PLATFORM=linux/amd64
-ARG GO_IMAGE=golang:1.22.4-alpine
+ARG GO_IMAGE=golang:1.22.4
 
 ARG GO_SRC=go-builder
 ARG JS_SRC=js-builder
@@ -32,7 +33,7 @@ COPY emails emails
 ENV NODE_ENV production
 RUN yarn build
 
-FROM ${GO_IMAGE} as go-builder
+FROM --platform=${JS_PLATFORM} ${GO_IMAGE} as go-builder
 
 ARG COMMIT_SHA=""
 ARG BUILD_BRANCH=""
@@ -84,6 +85,19 @@ COPY .github .github
 ENV COMMIT_SHA=${COMMIT_SHA}
 ENV BUILD_BRANCH=${BUILD_BRANCH}
 
+RUN make gen-go WIRE_TAGS=${WIRE_TAGS}
+
+FROM ${GO_SRC} as go-build-amd64
+RUN make build-go GO_BUILD_TAGS=${GO_BUILD_TAGS} WIRE_TAGS=${WIRE_TAGS}
+
+FROM ${GO_SRC} as go-build-arm64
+
+RUN apt-get update && \
+    apt-get -y install gcc-aarch64-linux-gnu;
+
+ENV GOARCH=arm64
+ENV CC=aarch64-linux-gnu-gcc
+
 RUN make build-go GO_BUILD_TAGS=${GO_BUILD_TAGS} WIRE_TAGS=${WIRE_TAGS}
 
 FROM ${BASE_IMAGE} as tgz-builder
@@ -98,7 +112,8 @@ COPY ${GRAFANA_TGZ} /tmp/grafana.tar.gz
 RUN tar x -z -f /tmp/grafana.tar.gz --strip-components=1
 
 # helpers for COPY --from
-FROM ${GO_SRC} as go-src
+ARG TARGETARCH
+FROM go-build-${TARGETARCH} as go-src
 FROM ${JS_SRC} as js-src
 
 # Final stage
@@ -191,3 +206,20 @@ COPY ${RUN_SH} /run.sh
 
 USER "$GF_UID"
 ENTRYPOINT [ "/run.sh" ]
+
+FROM grafana/grafana:${GF_VERSION}-ubuntu as groundcover
+
+COPY --from=go-src /tmp/grafana/bin/grafana* /tmp/grafana/bin/*/grafana* ./bin/
+COPY --from=js-src /tmp/grafana/public ./public
+
+USER 0
+
+ENV GF_PLUGIN_DIR="/usr/share/grafana/plugins" \
+    GF_PATHS_PLUGINS="/usr/share/grafana/plugins"
+
+RUN mkdir -p ${GF_PLUGIN_DIR} && \
+    chmod -R 777 ${GF_PLUGIN_DIR} && \
+    grafana cli plugins install grafana-clickhouse-datasource 4.0.3 && \
+    grafana cli plugins install marcusolsson-treemap-panel 2.0.1
+
+USER "$GF_UID"
diff --git a/pkg/api/accesscontrol.go b/pkg/api/accesscontrol.go
index 0b1cac3cc2b..c82eb794506 100644
--- a/pkg/api/accesscontrol.go
+++ b/pkg/api/accesscontrol.go
@@ -232,8 +232,8 @@ func (hs *HTTPServer) declareFixedRoles() error {
 			Group:       "Organizations",
 			Permissions: ac.ConcatPermissions(orgReaderRole.Role.Permissions, []ac.Permission{
 				{Action: ac.ActionOrgsPreferencesRead},
-				{Action: ac.ActionOrgsWrite},
-				{Action: ac.ActionOrgsPreferencesWrite},
+				// {Action: ac.ActionOrgsWrite},
+				// {Action: ac.ActionOrgsPreferencesWrite},
 			}),
 		},
 		Grants: []string{string(org.RoleAdmin)},
@@ -293,12 +293,12 @@ func (hs *HTTPServer) declareFixedRoles() error {
 			Description: "Create, read, write, or delete a team as well as controlling team memberships.",
 			Group:       "Teams",
 			Permissions: []ac.Permission{
-				{Action: ac.ActionTeamsCreate},
-				{Action: ac.ActionTeamsDelete, Scope: ac.ScopeTeamsAll},
+				// {Action: ac.ActionTeamsCreate},
+				// {Action: ac.ActionTeamsDelete, Scope: ac.ScopeTeamsAll},
 				{Action: ac.ActionTeamsPermissionsRead, Scope: ac.ScopeTeamsAll},
-				{Action: ac.ActionTeamsPermissionsWrite, Scope: ac.ScopeTeamsAll},
+				// {Action: ac.ActionTeamsPermissionsWrite, Scope: ac.ScopeTeamsAll},
 				{Action: ac.ActionTeamsRead, Scope: ac.ScopeTeamsAll},
-				{Action: ac.ActionTeamsWrite, Scope: ac.ScopeTeamsAll},
+				// {Action: ac.ActionTeamsWrite, Scope: ac.ScopeTeamsAll},
 			},
 		},
 		Grants: []string{string(org.RoleAdmin)},
diff --git a/pkg/services/ngalert/accesscontrol.go b/pkg/services/ngalert/accesscontrol.go
index 84b981fd2ab..f3776698114 100644
--- a/pkg/services/ngalert/accesscontrol.go
+++ b/pkg/services/ngalert/accesscontrol.go
@@ -209,7 +209,7 @@ var (
 				},
 			},
 		},
-		Grants: []string{string(org.RoleAdmin)},
+		Grants: []string{string(org.RoleEditor), string(org.RoleAdmin)},
 	}
 
 	alertingProvisioningReaderWithSecretsRole = accesscontrol.RoleRegistration{
diff --git a/pkg/services/ngalert/ngalert.go b/pkg/services/ngalert/ngalert.go
index b85aa73a871..da48511aebe 100644
--- a/pkg/services/ngalert/ngalert.go
+++ b/pkg/services/ngalert/ngalert.go
@@ -158,7 +158,7 @@ type AlertNG struct {
 
 func (ng *AlertNG) init() error {
 	// AlertNG should be initialized before the cancellation deadline of initCtx
-	initCtx, cancelFunc := context.WithTimeout(context.Background(), 30*time.Second)
+	initCtx, cancelFunc := context.WithTimeout(context.Background(), 90*time.Second)
 	defer cancelFunc()
 
 	ng.store.Logger = ng.Log
@@ -595,6 +595,7 @@ func configureHistorianBackend(ctx context.Context, cfg setting.UnifiedAlertingS
 		return historian.NewAnnotationBackend(annotationBackendLogger, store, rs, met, ac), nil
 	}
 	if backend == historian.BackendTypeLoki {
+		l.Info(fmt.Sprintf("loki state history backend is enabled, log all changes %v, otel enabled %v", cfg.LogAll, cfg.OtelEnabled))
 		lcfg, err := historian.NewLokiConfig(cfg)
 		if err != nil {
 			return nil, fmt.Errorf("invalid remote loki configuration: %w", err)
diff --git a/pkg/services/ngalert/state/historian/loki.go b/pkg/services/ngalert/state/historian/loki.go
index 9d125fe2384..7375717c6aa 100644
--- a/pkg/services/ngalert/state/historian/loki.go
+++ b/pkg/services/ngalert/state/historian/loki.go
@@ -79,17 +79,19 @@ type RemoteLokiBackend struct {
 	clock          clock.Clock
 	metrics        *metrics.Historian
 	log            log.Logger
+	logAll         bool
 	ac             AccessControl
 	ruleStore      RuleStore
 }
 
 func NewRemoteLokiBackend(logger log.Logger, cfg LokiConfig, req client.Requester, metrics *metrics.Historian, tracer tracing.Tracer, ruleStore RuleStore, ac AccessControl) *RemoteLokiBackend {
 	return &RemoteLokiBackend{
-		client:         NewLokiClient(cfg, req, metrics, logger, tracer),
+		client:         NewHistorianExportClient(cfg, req, metrics, logger, tracer),
 		externalLabels: cfg.ExternalLabels,
 		clock:          clock.New(),
 		metrics:        metrics,
 		log:            logger,
+		logAll:         cfg.LogAll,
 		ac:             ac,
 		ruleStore:      ruleStore,
 	}
@@ -102,7 +104,7 @@ func (h *RemoteLokiBackend) TestConnection(ctx context.Context) error {
 // Record writes a number of state transitions for a given rule to an external Loki instance.
 func (h *RemoteLokiBackend) Record(ctx context.Context, rule history_model.RuleMeta, states []state.StateTransition) <-chan error {
 	logger := h.log.FromContext(ctx)
-	logStream := StatesToStream(rule, states, h.externalLabels, logger)
+	logStream := StatesToStream(rule, states, h.externalLabels, logger, h.logAll)
 
 	errCh := make(chan error, 1)
 	if len(logStream.Values) == 0 {
@@ -269,7 +271,7 @@ func merge(res []Stream, folderUIDToFilter []string) (*data.Frame, error) {
 	return frame, nil
 }
 
-func StatesToStream(rule history_model.RuleMeta, states []state.StateTransition, externalLabels map[string]string, logger log.Logger) Stream {
+func StatesToStream(rule history_model.RuleMeta, states []state.StateTransition, externalLabels map[string]string, logger log.Logger, logAll bool) Stream {
 	labels := mergeLabels(make(map[string]string), externalLabels)
 	// System-defined labels take precedence over user-defined external labels.
 	labels[StateHistoryLabelKey] = StateHistoryLabelValue
@@ -279,7 +281,7 @@ func StatesToStream(rule history_model.RuleMeta, states []state.StateTransition,
 
 	samples := make([]Sample, 0, len(states))
 	for _, state := range states {
-		if !shouldRecord(state) {
+		if !shouldRecord(state) && !logAll {
 			continue
 		}
 
@@ -537,3 +539,11 @@ func (h *RemoteLokiBackend) getFolderUIDsForFilter(ctx context.Context, query mo
 	sort.Strings(uids)
 	return uids, nil
 }
+
+func NewHistorianExportClient(cfg LokiConfig, req client.Requester, metrics *metrics.Historian, logger log.Logger, tracer tracing.Tracer) remoteLokiClient {
+	if cfg.OtelConfig.Enabled {
+		return NewOtelLokiClient(cfg.OtelConfig, metrics)
+	}
+
+	return NewLokiClient(cfg, req, metrics, logger, tracer)
+}
diff --git a/pkg/services/ngalert/state/historian/loki_http.go b/pkg/services/ngalert/state/historian/loki_http.go
index c925dc361c5..9304bd20d18 100644
--- a/pkg/services/ngalert/state/historian/loki_http.go
+++ b/pkg/services/ngalert/state/historian/loki_http.go
@@ -42,6 +42,8 @@ type LokiConfig struct {
 	ExternalLabels    map[string]string
 	Encoder           encoder
 	MaxQueryLength    time.Duration
+	LogAll            bool
+	OtelConfig        OtelConfig
 	MaxQuerySize      int
 }
 
@@ -81,6 +83,15 @@ func NewLokiConfig(cfg setting.UnifiedAlertingStateHistorySettings) (LokiConfig,
 		MaxQuerySize:      cfg.LokiMaxQuerySize,
 		// Snappy-compressed protobuf is the default, same goes for Promtail.
 		Encoder: SnappyProtoEncoder{},
+		LogAll:  cfg.LogAll,
+		OtelConfig: OtelConfig{
+			Enabled:       cfg.OtelEnabled,
+			Endpoint:      cfg.OtelEndpoint,
+			EnableTLS:     cfg.OtelEnableTLS,
+			TLSSkipVerify: cfg.OtelTLSSkipVerify,
+			ApiKey:        cfg.OtelApiKey,
+			MaxQuerySize:  cfg.LokiMaxQuerySize,
+		},
 	}, nil
 }
 
diff --git a/pkg/services/ngalert/state/historian/otel_loki_client.go b/pkg/services/ngalert/state/historian/otel_loki_client.go
new file mode 100644
index 00000000000..11acafc555e
--- /dev/null
+++ b/pkg/services/ngalert/state/historian/otel_loki_client.go
@@ -0,0 +1,350 @@
+package historian
+
+import (
+	"bytes"
+	"compress/gzip"
+	"context"
+	"crypto/tls"
+	"encoding/json"
+	"fmt"
+	"net/http"
+	"net/url"
+	"strconv"
+	"sync"
+	"time"
+
+	"github.com/grafana/grafana/pkg/services/ngalert/metrics"
+	"github.com/unknwon/log"
+	"github.com/valyala/bytebufferpool"
+	"go.opentelemetry.io/collector/pdata/pcommon"
+	"go.opentelemetry.io/collector/pdata/plog"
+	"go.opentelemetry.io/collector/pdata/plog/plogotlp"
+	"google.golang.org/grpc"
+	"google.golang.org/grpc/credentials"
+	"google.golang.org/grpc/credentials/insecure"
+	"google.golang.org/grpc/metadata"
+)
+
+var (
+	_            remoteLokiClient = (*otelLokiClient)(nil)
+	payloadsPool                  = bytebufferpool.Pool{}
+)
+
+type OtelConfig struct {
+	Enabled       bool
+	MaxQuerySize  int
+	WriteTimeout  time.Duration
+	Endpoint      string
+	EnableTLS     bool
+	TLSSkipVerify bool
+	ApiKey        string
+}
+
+func (c OtelConfig) HttpMode() bool {
+	u, err := url.Parse(c.Endpoint)
+	if err != nil {
+		return false
+	}
+
+	return u.Scheme == "http" || u.Scheme == "https"
+}
+
+func (c OtelConfig) GetWriteTimeout() time.Duration {
+	const writeTimeoutDefault = 5 * time.Second
+	if c.WriteTimeout == 0 {
+		return writeTimeoutDefault
+	}
+
+	return c.WriteTimeout
+}
+
+type otelLokiClient struct {
+	grpcClient plogotlp.GRPCClient
+	httpClient *http.Client
+	once       *sync.Once
+	cfg        OtelConfig
+	metrics    *metrics.Historian
+	httpMode   bool
+}
+
+func NewOtelLokiClient(cfg OtelConfig, metrics *metrics.Historian) *otelLokiClient {
+	return &otelLokiClient{
+		once:     &sync.Once{},
+		cfg:      cfg,
+		metrics:  metrics,
+		httpMode: cfg.HttpMode(),
+	}
+}
+
+func (p *otelLokiClient) Ping(context.Context) error {
+	return nil
+}
+
+func (p *otelLokiClient) RangeQuery(ctx context.Context, logQL string, start, end, limit int64) (QueryRes, error) {
+	return QueryRes{}, fmt.Errorf("unsupported operation")
+}
+
+func (p *otelLokiClient) initClient() (err error) {
+	p.once.Do(func() {
+		if p.httpMode {
+			err = p.initHTTPClient(p.cfg)
+			return
+		}
+
+		err = p.initGrpcClient(p.cfg)
+	})
+
+	if err != nil {
+		return fmt.Errorf("failed to create otel loki client: %w", err)
+	}
+
+	return nil
+}
+
+func (p *otelLokiClient) initGrpcClient(cfg OtelConfig) error {
+	conn, err := newOtlpGrpcConn(cfg)
+	if err != nil {
+		return err
+	}
+
+	p.grpcClient = plogotlp.NewGRPCClient(conn)
+	return nil
+}
+
+func (p *otelLokiClient) initHTTPClient(cfg OtelConfig) error {
+	p.httpClient = &http.Client{
+		Transport: getOTLPHTTPConnectionTransport(cfg),
+	}
+	return nil
+}
+
+func (p *otelLokiClient) MaxQuerySize() int {
+	return p.cfg.MaxQuerySize
+}
+
+func (p *otelLokiClient) Push(ctx context.Context, s []Stream) (err error) {
+	const (
+		exportGRPCMethodName = "otelExportGRPC"
+		exportHTTPMethodName = "otelExportHTTP"
+	)
+
+	exportStart := time.Now()
+	logs, size, err := p.pushRequestToLogs(s, time.Now())
+	if err != nil {
+		return err
+	}
+
+	timeoutCtx, cancelFunc := context.WithTimeout(ctx, p.cfg.GetWriteTimeout())
+	defer cancelFunc()
+
+	req := plogotlp.NewExportRequestFromLogs(logs)
+
+	var status string
+	var method string
+	if p.httpMode {
+		method = exportHTTPMethodName
+		p.metrics.WriteDuration.Before(ctx, exportHTTPMethodName, exportStart)
+		status, err = p.pushHttp(timeoutCtx, &req)
+	} else {
+		method = exportGRPCMethodName
+		p.metrics.WriteDuration.Before(ctx, exportGRPCMethodName, exportStart)
+		status, err = p.pushGrpc(timeoutCtx, &req)
+	}
+
+	if err != nil {
+		return fmt.Errorf("failed to export logs: %w", err)
+	}
+
+	p.metrics.WriteDuration.After(ctx, method, status, exportStart)
+	p.metrics.BytesWritten.Add(float64(size))
+	return nil
+}
+
+func (p *otelLokiClient) pushHttp(ctx context.Context, req *plogotlp.ExportRequest) (status string, err error) {
+	const (
+		contentTypeHeader   = "Content-Type"
+		apiKeyHeader        = "apikey"
+		protobufContentType = "application/x-protobuf"
+		contentEncoding     = "Content-Encoding"
+		contentEncodingGzip = "gzip"
+	)
+
+	err = p.initClient()
+	if err != nil {
+		return "", err
+	}
+
+	protoBody, err := req.MarshalProto()
+	if err != nil {
+		return "", fmt.Errorf("failed to marshal logs: %w", err)
+	}
+
+	gzippedBuffer := payloadsPool.Get()
+	defer payloadsPool.Put(gzippedBuffer)
+
+	gzipWriter := gzip.NewWriter(gzippedBuffer)
+	_, err = gzipWriter.Write(protoBody)
+	if err != nil {
+		return "", fmt.Errorf("failed to gzip request: %w", err)
+	}
+
+	err = gzipWriter.Close()
+	if err != nil {
+		return "", fmt.Errorf("failed to close the gzip writer: %w", err)
+	}
+
+	httpReq, err := http.NewRequestWithContext(ctx, http.MethodPost, p.cfg.Endpoint, bytes.NewReader(gzippedBuffer.Bytes()))
+	if err != nil {
+		return "", fmt.Errorf("failed to create http request: %w", err)
+	}
+
+	httpReq.Header.Set(contentEncoding, contentEncodingGzip)
+	httpReq.Header.Set(contentTypeHeader, protobufContentType)
+	if p.cfg.ApiKey != "" {
+		httpReq.Header.Set(apiKeyHeader, p.cfg.ApiKey)
+	}
+
+	response, err := p.httpClient.Do(httpReq)
+	if err != nil {
+		return "", fmt.Errorf("failed to send http request: %w", err)
+	}
+
+	defer response.Body.Close()
+	return strconv.Itoa(response.StatusCode), nil
+}
+
+func (p *otelLokiClient) pushGrpc(ctx context.Context, req *plogotlp.ExportRequest) (status string, err error) {
+	const (
+		failureCode = "1"
+		successCode = "0"
+	)
+
+	err = p.initClient()
+	if err != nil {
+		return "", err
+	}
+
+	_, err = p.grpcClient.Export(ctx, *req)
+	if err != nil {
+		return failureCode, err
+	}
+
+	return successCode, nil
+}
+
+func (p *otelLokiClient) pushRequestToLogs(sreams []Stream, observedTimestamp time.Time) (plog.Logs, int, error) {
+	logs := plog.NewLogs()
+	if len(sreams) == 0 {
+		return logs, 0, nil
+	}
+	rls := logs.ResourceLogs().AppendEmpty()
+	logSlice := rls.ScopeLogs().AppendEmpty().LogRecords()
+	totalSize := 0
+
+	var lastErr error
+	var errNumber int64
+	for _, stream := range sreams {
+		// Return early if stream does not contain any entries
+		if len(stream.Stream) == 0 {
+			continue
+		}
+
+		totalSize += calcAttributesSize(stream.Stream)
+
+		for _, entry := range stream.Values {
+			lr := logSlice.AppendEmpty()
+			convertEntryToLogRecord(entry, stream.Stream, &lr, observedTimestamp)
+			totalSize += len(entry.V)
+		}
+	}
+
+	if lastErr != nil {
+		lastErr = fmt.Errorf("%d entries failed to process, the last error: %w", errNumber, lastErr)
+	}
+
+	return logs, totalSize, lastErr
+}
+
+func convertEntryToLogRecord(entry Sample, streamAttributes map[string]string, lr *plog.LogRecord, defaultTimestamp time.Time) error {
+	const timestampAttribute = "timestamp"
+
+	observedTimestamp := pcommon.NewTimestampFromTime(defaultTimestamp)
+	lr.SetObservedTimestamp(observedTimestamp)
+
+	var recordAttributes map[string]any
+	err := json.Unmarshal([]byte(entry.V), &recordAttributes)
+	if err != nil {
+		return fmt.Errorf("failed to unmarshal log line: %w", err)
+	}
+
+	var timestamp pcommon.Timestamp
+	if !entry.T.IsZero() {
+		timestamp = pcommon.NewTimestampFromTime(entry.T)
+	} else {
+		timestamp = observedTimestamp
+	}
+
+	lr.SetTimestamp(timestamp)
+	lr.Attributes().FromRaw(recordAttributes)
+	attributes := lr.Attributes()
+	attributes.PutStr(timestampAttribute, timestamp.AsTime().Format(time.RFC3339Nano))
+	for k, v := range streamAttributes {
+		attributes.PutStr(k, v)
+	}
+
+	return nil
+}
+
+func calcAttributesSize(attributes map[string]string) int {
+	size := 0
+	for k, v := range attributes {
+		size += len(k) + len(v)
+	}
+	return size
+}
+
+func newOtlpGrpcConn(cfg OtelConfig) (conn *grpc.ClientConn, err error) {
+	const (
+		apiKeyHeader                 = "apikey"
+		defaultConnectionDialTimeout = 10 * time.Second
+	)
+	creds := insecure.NewCredentials()
+	if cfg.EnableTLS {
+		config := &tls.Config{
+			InsecureSkipVerify: cfg.TLSSkipVerify,
+		}
+		creds = credentials.NewTLS(config)
+		log.Info("Establishing grpcs connection")
+	} else {
+		log.Info("Establishing not encrypted grpc connection")
+	}
+
+	options := []grpc.DialOption{
+		grpc.WithTransportCredentials(creds),
+	}
+
+	if cfg.ApiKey != "" {
+		options = append(options, grpc.WithUnaryInterceptor(func(ctx context.Context, method string, req interface{}, reply interface{},
+			cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
+
+			ctx = metadata.AppendToOutgoingContext(ctx, apiKeyHeader, cfg.ApiKey)
+			return invoker(ctx, method, req, reply, cc, opts...)
+		}))
+	}
+
+	ctx, cancel := context.WithTimeout(context.Background(), defaultConnectionDialTimeout)
+	defer cancel()
+	return grpc.DialContext(ctx, cfg.Endpoint, options...)
+}
+
+func getOTLPHTTPConnectionTransport(otelConfig OtelConfig) *http.Transport {
+	if otelConfig.EnableTLS {
+		return &http.Transport{
+			TLSClientConfig: &tls.Config{
+				InsecureSkipVerify: otelConfig.TLSSkipVerify,
+			},
+		}
+	}
+
+	return &http.Transport{}
+}
diff --git a/pkg/setting/setting_unified_alerting.go b/pkg/setting/setting_unified_alerting.go
index 49807306148..2a01887af3a 100644
--- a/pkg/setting/setting_unified_alerting.go
+++ b/pkg/setting/setting_unified_alerting.go
@@ -2,6 +2,7 @@ package setting
 
 import (
 	"fmt"
+	"os"
 	"strconv"
 	"strings"
 	"time"
@@ -168,6 +169,12 @@ type UnifiedAlertingStateHistorySettings struct {
 	MultiPrimary          string
 	MultiSecondaries      []string
 	ExternalLabels        map[string]string
+	LogAll                bool
+	OtelEnabled           bool
+	OtelEndpoint          string
+	OtelEnableTLS         bool
+	OtelTLSSkipVerify     bool
+	OtelApiKey            string
 }
 
 // IsEnabled returns true if UnifiedAlertingSettings.Enabled is either nil or true.
@@ -416,6 +423,12 @@ func (cfg *Cfg) ReadUnifiedAlertingSettings(iniFile *ini.File) error {
 		MultiPrimary:          stateHistory.Key("primary").MustString(""),
 		MultiSecondaries:      splitTrim(stateHistory.Key("secondaries").MustString(""), ","),
 		ExternalLabels:        stateHistoryLabels.KeysHash(),
+		LogAll:                stateHistory.Key("log_all").MustBool(false),
+		OtelEnabled:           stateHistory.Key("otel_export_enabled").MustBool(false),
+		OtelEndpoint:          stateHistory.Key("otel_endpoint").MustString(""),
+		OtelEnableTLS:         stateHistory.Key("otel_enable_tls").MustBool(false),
+		OtelTLSSkipVerify:     stateHistory.Key("otel_tls_skip_verify").MustBool(false),
+		OtelApiKey:            os.Getenv("API_KEY"),
 	}
 	uaCfg.StateHistory = uaCfgStateHistory
 
diff --git a/public/app/core/components/AppChrome/AppChromeService.tsx b/public/app/core/components/AppChrome/AppChromeService.tsx
index 5c1d88ebb41..712a25110e8 100644
--- a/public/app/core/components/AppChrome/AppChromeService.tsx
+++ b/public/app/core/components/AppChrome/AppChromeService.tsx
@@ -49,7 +49,7 @@ export class AppChromeService {
     chromeless: true, // start out hidden to not flash it on pages without chrome
     sectionNav: { node: { text: t('nav.home.title', 'Home') }, main: { text: '' } },
     searchBarHidden: store.getBool(this.searchBarStorageKey, false),
-    megaMenuOpen: this.megaMenuDocked && store.getBool(DOCKED_MENU_OPEN_LOCAL_STORAGE_KEY, true),
+    megaMenuOpen: this.megaMenuDocked && store.getBool(DOCKED_MENU_OPEN_LOCAL_STORAGE_KEY, false),
     megaMenuDocked: this.megaMenuDocked,
     kioskMode: null,
     layout: PageLayoutType.Canvas,
diff --git a/public/app/core/components/AppChrome/TopBar/TopSearchBar.tsx b/public/app/core/components/AppChrome/TopBar/TopSearchBar.tsx
index 92ef3dd70ca..0daf4a268ae 100644
--- a/public/app/core/components/AppChrome/TopBar/TopSearchBar.tsx
+++ b/public/app/core/components/AppChrome/TopBar/TopSearchBar.tsx
@@ -12,7 +12,7 @@ import { useSelector } from 'app/types';
 import { Branding } from '../../Branding/Branding';
 import { enrichHelpItem } from '../MegaMenu/utils';
 import { NewsContainer } from '../News/NewsContainer';
-import { OrganizationSwitcher } from '../OrganizationSwitcher/OrganizationSwitcher';
+// import { OrganizationSwitcher } from '../OrganizationSwitcher/OrganizationSwitcher';
 import { QuickAdd } from '../QuickAdd/QuickAdd';
 import { TOP_BAR_LEVEL_HEIGHT } from '../types';
 
@@ -41,7 +41,7 @@ export const TopSearchBar = memo(function TopSearchBar() {
         <a className={styles.logo} href={homeUrl} title="Go to home">
           <Branding.MenuLogo className={styles.img} />
         </a>
-        <OrganizationSwitcher />
+        {/* <OrganizationSwitcher /> */}
       </TopSearchBarSection>
 
       <TopSearchBarSection>
diff --git a/public/app/features/alerting/unified/utils/rule-form.ts b/public/app/features/alerting/unified/utils/rule-form.ts
index 960e24e07da..75c74e481f7 100644
--- a/public/app/features/alerting/unified/utils/rule-form.ts
+++ b/public/app/features/alerting/unified/utils/rule-form.ts
@@ -86,8 +86,8 @@ export const getDefaultFormValues = (): RuleFormValues => {
     queries: [],
     recordingRulesQueries: [],
     condition: '',
-    noDataState: GrafanaAlertStateDecision.NoData,
-    execErrState: GrafanaAlertStateDecision.Error,
+    noDataState: GrafanaAlertStateDecision.OK,
+    execErrState: GrafanaAlertStateDecision.OK,
     evaluateFor: DEFAULT_GROUP_EVALUATION_INTERVAL,
     evaluateEvery: DEFAULT_GROUP_EVALUATION_INTERVAL,
     manualRouting: getDefautManualRouting(), // we default to true if the feature toggle is enabled and the user hasn't set local storage to false
diff --git a/public/app/features/dashboard-scene/settings/variables/components/SelectionOptionsForm.tsx b/public/app/features/dashboard-scene/settings/variables/components/SelectionOptionsForm.tsx
index de2ba28a91f..2cddb5dc311 100644
--- a/public/app/features/dashboard-scene/settings/variables/components/SelectionOptionsForm.tsx
+++ b/public/app/features/dashboard-scene/settings/variables/components/SelectionOptionsForm.tsx
@@ -40,10 +40,10 @@ export function SelectionOptionsForm({
       />
       {includeAll && (
         <VariableTextField
-          defaultValue={allValue ?? ''}
+          defaultValue={allValue ?? '.*'}
           onBlur={onAllValueChange}
           name="Custom all value"
-          placeholder="blank = auto"
+          placeholder=".*"
           testId={selectors.pages.Dashboard.Settings.Variables.Edit.General.selectionOptionsCustomAllInput}
         />
       )}
diff --git a/public/app/features/profile/UserProfileEditPage.test.tsx b/public/app/features/profile/UserProfileEditPage.test.tsx
index a8e27dcd80d..b2134a3c546 100644
--- a/public/app/features/profile/UserProfileEditPage.test.tsx
+++ b/public/app/features/profile/UserProfileEditPage.test.tsx
@@ -242,26 +242,26 @@ describe('UserProfileEditPage', () => {
       });
     });
 
-    describe('and organizations are loading', () => {
-      it('should show teams loading placeholder', async () => {
-        await getTestContext({ orgsAreLoading: true });
-
-        expect(screen.getByText(/loading organizations\.\.\./i)).toBeInTheDocument();
-      });
-    });
-
-    describe('and organizations are loaded', () => {
-      it('should show organizations', async () => {
-        await getTestContext();
-
-        const { orgsTable, orgsEditorRow, orgsViewerRow, orgsAdminRow } = getSelectors();
-        expect(screen.getByRole('heading', { name: /organizations/i })).toBeInTheDocument();
-        expect(orgsTable()).toBeInTheDocument();
-        expect(orgsEditorRow()).toBeInTheDocument();
-        expect(orgsViewerRow()).toBeInTheDocument();
-        expect(orgsAdminRow()).toBeInTheDocument();
-      });
-    });
+    // describe('and organizations are loading', () => {
+    //   it('should show teams loading placeholder', async () => {
+    //     await getTestContext({ orgsAreLoading: true });
+
+    //     expect(screen.getByText(/loading organizations\.\.\./i)).toBeInTheDocument();
+    //   });
+    // });
+
+    // describe('and organizations are loaded', () => {
+    //   it('should show organizations', async () => {
+    //     await getTestContext();
+
+    //     const { orgsTable, orgsEditorRow, orgsViewerRow, orgsAdminRow } = getSelectors();
+    //     expect(screen.getByRole('heading', { name: /organizations/i })).toBeInTheDocument();
+    //     expect(orgsTable()).toBeInTheDocument();
+    //     expect(orgsEditorRow()).toBeInTheDocument();
+    //     expect(orgsViewerRow()).toBeInTheDocument();
+    //     expect(orgsAdminRow()).toBeInTheDocument();
+    //   });
+    // });
 
     describe('and sessions are loading', () => {
       it('should show teams loading placeholder', async () => {
@@ -300,24 +300,24 @@ describe('UserProfileEditPage', () => {
       });
     });
 
-    describe('and organization is changed', () => {
-      it('should call changeUserOrg', async () => {
-        const { props } = await getTestContext();
-        const orgsAdminSelectButton = () =>
-          within(getSelectors().orgsAdminRow()).getByRole('button', {
-            name: /select organisation/i,
-          });
-
-        await userEvent.click(orgsAdminSelectButton());
-
-        await waitFor(() => expect(props.changeUserOrg).toHaveBeenCalledTimes(1));
-        expect(props.changeUserOrg).toHaveBeenCalledWith({
-          name: 'Third',
-          orgId: 2,
-          role: 'Admin',
-        });
-      });
-    });
+    // describe('and organization is changed', () => {
+    //   it('should call changeUserOrg', async () => {
+    //     const { props } = await getTestContext();
+    //     const orgsAdminSelectButton = () =>
+    //       within(getSelectors().orgsAdminRow()).getByRole('button', {
+    //         name: /select organisation/i,
+    //       });
+
+    //     await userEvent.click(orgsAdminSelectButton());
+
+    //     await waitFor(() => expect(props.changeUserOrg).toHaveBeenCalledTimes(1));
+    //     expect(props.changeUserOrg).toHaveBeenCalledWith({
+    //       name: 'Third',
+    //       orgId: 2,
+    //       role: 'Admin',
+    //     });
+    //   });
+    // });
 
     describe('and session is revoked', () => {
       it('should call revokeUserSession', async () => {
diff --git a/public/app/features/profile/UserProfileEditPage.tsx b/public/app/features/profile/UserProfileEditPage.tsx
index 4de0ebee3d4..5cd73ed391f 100644
--- a/public/app/features/profile/UserProfileEditPage.tsx
+++ b/public/app/features/profile/UserProfileEditPage.tsx
@@ -12,7 +12,7 @@ import { useQueryParams } from 'app/core/hooks/useQueryParams';
 import { t } from 'app/core/internationalization';
 import { StoreState } from 'app/types';
 
-import UserOrganizations from './UserOrganizations';
+// import UserOrganizations from './UserOrganizations';
 import UserProfileEditForm from './UserProfileEditForm';
 import UserSessions from './UserSessions';
 import { UserTeams } from './UserTeams';
@@ -108,7 +108,7 @@ export function UserProfileEditPage({
       <SharedPreferences resourceUri="user" preferenceType="user" />
       <Stack direction="column" gap={6}>
         <UserTeams isLoading={teamsAreLoading} teams={teams} />
-        <UserOrganizations isLoading={orgsAreLoading} setUserOrg={changeUserOrg} orgs={orgs} user={user} />
+        {/* <UserOrganizations isLoading={orgsAreLoading} setUserOrg={changeUserOrg} orgs={orgs} user={user} /> */}
         <UserSessions isLoading={sessionsAreLoading} revokeUserSession={revokeUserSession} sessions={sessions} />
       </Stack>
     </Stack>
